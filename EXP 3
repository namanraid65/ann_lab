def perceptron_logic(gate, inputs):
    n = len(inputs)
    gate = gate.upper()

    # Define weights and thresholds for each gate
    if gate in ["AND", "OR", "NAND", "NOR"]:
        w = [1] * n
        t = n if gate in ["AND", "NAND"] else 1
    elif gate == "NOT":
        if n != 1:
            return "NOT gate only accepts 1 input."
        w = [-1]
        t = 0
    else:
        return "Invalid gate selected."

    # Calculate weighted sum
    summation = sum(i * j for i, j in zip(w, inputs))

    # Determine output
    if gate in ["NAND", "NOR"]:
        output = int(summation < t)
    else:
        output = int(summation >= t)

    return output


def get_inputs(num_inputs, gate):
    """Collects valid binary inputs from the user."""
    inputs = []
    for i in range(num_inputs):
        while True:
            try:
                x = int(input(f"Enter input {i + 1} (0 or 1): "))
                if x in [0, 1]:
                    inputs.append(x)
                    break
                print("Only 0 or 1 allowed.")
            except ValueError:
                print("Enter a valid integer (0 or 1).")
    return inputs


def main():
    while True:
        print("\nAvailable Gates: AND, OR, NOT, NAND, NOR")
        gate = input("Enter logic gate: ").strip().upper()

        try:
            num_inputs = int(input("\nEnter number of inputs: "))
            if gate == "NOT" and num_inputs != 1:
                print("NOT gate only accepts 1 input.")
                continue
        except ValueError:
            print("Invalid number!")
            continue

        inputs = get_inputs(num_inputs, gate)
        result = perceptron_logic(gate, inputs)
        print(f"{gate} Gate: {inputs} â‡’ {result}")

        again = input("\nDo you want to try again? (yes/no): ").strip().lower()
        if again != "yes":
            print("Program exited.")
            break


if __name__ == "__main__":
    main()
